# Cursor. (2026). Cursor Composer (Version 1.5) [Large language model]. https://cursor.com/
# Citation applies to: Lines 1-final. Generated by Cursor; revised and integrated by me.
#
# Data analyzer API: queries DB for weather/snow, computes ski score. CORS enabled for all origins.
from data_collector.observability import setup_observability

setup_observability(service_name="ski-analyzer")

import asyncio
import json
from contextlib import asynccontextmanager
import re
from datetime import datetime, timedelta
from fastapi import FastAPI, Depends
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from pydantic import BaseModel
from data_collector.database import get_db
from data_collector.models import Location, WeatherRecord, SnowRecord


@asynccontextmanager
async def lifespan(app: FastAPI):
    yield


app = FastAPI(title="Colorado Ski Score Analyzer", lifespan=lifespan)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor

FastAPIInstrumentor.instrument_app(app)

# health check for product environment monitoring
@app.get("/health")
def health():
    return {"status": "ok"}


_event_queues: list[asyncio.Queue] = []

# async generator that yields SSE events when weather data is updated
async def _event_stream():
    queue: asyncio.Queue = asyncio.Queue()
    _event_queues.append(queue)
    try:
        while True:
            msg = await queue.get()
            yield f"data: {json.dumps({'event': 'weather_data_updated', 'message': msg})}\n\n"
    except asyncio.CancelledError:
        pass
    finally:
        if queue in _event_queues:
            _event_queues.remove(queue)


@app.get("/events")
async def events():
    return StreamingResponse(
        _event_stream(),
        media_type="text/event-stream",
        headers={"Cache-Control": "no-cache", "Connection": "keep-alive"},
    )


@app.post("/internal/notify")
async def notify_subscribers():
    for q in _event_queues:
        try:
            q.put_nowait("weather_data_updated")
        except Exception:
            pass
    return {"status": "ok", "subscribers": len(_event_queues)}


class SkiScoreDetail(BaseModel):
    temperature_score: float
    wind_score: float
    snow_score: float
    conditions_score: float
    factors: dict


class SkiScoreResult(BaseModel):
    resort_name: str
    score: float
    details: SkiScoreDetail | None = None


class SkiScoresResponse(BaseModel):
    scores: list[SkiScoreResult]

def _parse_wind_mph(wind_speed: str | None) -> float:
    if not wind_speed:
        return 0.0
    numbers = re.findall(r"[\d.]+", wind_speed)
    if not numbers:
        return 0.0
    return sum(float(n) for n in numbers) / len(numbers)


def _snowfall_to_inches(value: float | None, unit: str | None) -> float:
    if value is None:
        return 0.0
    return value * 0.3937  # 2.54 cm per inch

# Currently not used
def _meters_to_inches(value: float | None) -> float:
    if value is None:
        return 0.0
    return value * 39.37


# ideal range for skiing is 15-30 F
def _temperature_score(temp_f: float | None) -> tuple[float, str]:
    if temp_f is None:
        return 0.0, "no data"
    if temp_f < -10:
        score = max(0, 5 + (temp_f + 10) * 0.5)
    elif temp_f < 15:
        score = 5 + (temp_f + 10) * (10 / 25)
    elif temp_f <= 30:
        score = 15 + (temp_f - 15) * (10 / 15)
    elif temp_f <= 45:
        score = 25 - (temp_f - 30)
    else:
        score = max(0, 10 - (temp_f - 45))
    return min(25, max(0, score)), f"{temp_f}Â°F"

# wind is bad
def _wind_score(wind_mph: float) -> tuple[float, str]:
    if wind_mph <= 5:
        score = 25
    elif wind_mph <= 15:
        score = 25 - (wind_mph - 5)
    elif wind_mph <= 25:
        score = 15 - (wind_mph - 15)
    else:
        score = max(0, 5 - (wind_mph - 25))
    return min(25, max(0, score)), f"{wind_mph:.1f} mph"

# the more snow the better
def _snow_score(
    recent_snowfall_in: float,
    forecast_snowfall_in: float,
    has_snow_in_forecast: bool,
) -> tuple[float, str]:
    
    base = 10

    if recent_snowfall_in > 0:
        base += min(8, recent_snowfall_in * 2)
    if forecast_snowfall_in > 0:
        base += min(5, forecast_snowfall_in * 2)
    if has_snow_in_forecast:
        base += 5
    note = f"recent: {recent_snowfall_in:.1f}\", forecast: {forecast_snowfall_in:.1f}\""
    return min(25, base), note

# snow = good, rain = bad, clear = neutral
def _conditions_score(short_forecast: str | None) -> tuple[float, str]:
    if not short_forecast:
        return 12.5, "no data"
    s = short_forecast.lower()
    if "snow" in s:
        return 22, "snow expected"
    elif "rain" in s:
        return 3, "rain expected"
    elif "clear" in s or "sunny" in s:
        return 15, "clear/sunny"
    # fallback
    return 12.5, "mixed"

# calls all the other functions to compute
def compute_ski_score(
    weather_records: list[WeatherRecord],
    snow_records: list[SnowRecord],
    include_details: bool = True,
) -> tuple[float, SkiScoreDetail | None]:

    now = datetime.utcnow()
    cutoff = now + timedelta(days=2)

    upcoming = [
        w
        for w in sorted(weather_records, key=lambda x: x.start_time)
        if w.start_time >= now and w.end_time <= cutoff and w.is_daytime
    ]
    if not upcoming:
        upcoming = [
            w
            for w in sorted(weather_records, key=lambda x: x.start_time)
            if w.start_time >= now and w.end_time <= cutoff
        ][:3]

    if not upcoming:
        upcoming = sorted(weather_records, key=lambda x: x.start_time)[:3]

    temp = upcoming[0].temperature if upcoming else None
    temp_score, temp_note = _temperature_score(temp)

    wind_values = [
        _parse_wind_mph(w.wind_speed)
        for w in upcoming
        if w.wind_speed
    ]
    wind_mph = sum(wind_values) / len(wind_values) if wind_values else 0.0
    wind_score, wind_note = _wind_score(wind_mph)
    recent_cutoff = now - timedelta(hours=48)

    forecast_cutoff = now + timedelta(hours=48)
    recent_snow = sum(
        _snowfall_to_inches(s.snowfall_amount, s.snowfall_unit)
        for s in snow_records
        if s.valid_time_start >= recent_cutoff
        and s.valid_time_start <= now
        and s.snowfall_amount
    )
    forecast_snow = sum(
        _snowfall_to_inches(s.snowfall_amount, s.snowfall_unit)
        for s in snow_records
        if s.valid_time_start >= now
        and s.valid_time_start <= forecast_cutoff
        and s.snowfall_amount
    )
    has_snow_forecast = any(
        "snow" in (w.short_forecast or "").lower()
        for w in upcoming
    )
    snow_score, snow_note = _snow_score(recent_snow, forecast_snow, has_snow_forecast)
    cond_forecast = upcoming[0].short_forecast if upcoming else None
    cond_score, cond_note = _conditions_score(cond_forecast)
    total = temp_score + wind_score + snow_score + cond_score

    if include_details:
        details = SkiScoreDetail(
            temperature_score=round(temp_score, 1),
            wind_score=round(wind_score, 1),
            snow_score=round(snow_score, 1),
            conditions_score=round(cond_score, 1),
            factors={
                "temperature": temp_note,
                "wind": wind_note,
                "snow": snow_note,
                "conditions": cond_note,
            },
        )
        return round(total, 1), details
    return round(total, 1), None


@app.get("/scores", response_model=SkiScoresResponse)
def get_ski_scores(
    include_details: bool = True,
    db: Session = Depends(get_db),
):
    locations = db.query(Location).all()
    results = []

    for loc in locations:
        weather = db.query(WeatherRecord).filter_by(location_id=loc.id).all()
        snow = db.query(SnowRecord).filter_by(location_id=loc.id).all()

        score, details = compute_ski_score(weather, snow, include_details)
        results.append(
            SkiScoreResult(
                resort_name=loc.name,
                score=score,
                details=details,
            )
        )

    results.sort(key=lambda r: r.score, reverse=True)

    return SkiScoresResponse(scores=results)


@app.get("/scores/{resort_name}", response_model=SkiScoreResult)
def get_resort_score(
    resort_name: str,
    include_details: bool = True,
    db: Session = Depends(get_db),
):
    loc = db.query(Location).filter(Location.name.ilike(resort_name)).first()
    if not loc:
        from fastapi import HTTPException
        raise HTTPException(status_code=404, detail=f"Resort '{resort_name}' not found")

    weather = db.query(WeatherRecord).filter_by(location_id=loc.id).all()
    snow = db.query(SnowRecord).filter_by(location_id=loc.id).all()

    score, details = compute_ski_score(weather, snow, include_details)

    return SkiScoreResult(
        resort_name=loc.name,
        score=score,
        details=details,
    )
