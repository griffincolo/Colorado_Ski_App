# Cursor. (2026). Cursor Composer (Version 1.5) [Large language model]. https://cursor.com/
# Citation applies to: Lines 1-final. Generated by Cursor; revised and integrated by me.
#
# Unit tests for the data collector API. Uses mocks for the NWS API to avoid real HTTP calls.
from unittest.mock import MagicMock, patch

import pytest
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session

from data_collector.database import get_db
from data_collector.main import app, sync_all_weather
from data_collector.models import Location, WeatherRecord, SnowRecord

# Mock NWS API responses
POINTS_RESPONSE = {
    "properties": {
        "forecast": "https://api.weather.gov/fake/forecast",
        "forecastGridData": "https://api.weather.gov/fake/gridpoint",
    }
}

FORECAST_RESPONSE = {
    "properties": {
        "periods": [
            {
                "number": 1,
                "name": "Today",
                "startTime": "2025-02-26T06:00:00-07:00",
                "endTime": "2025-02-26T18:00:00-07:00",
                "isDaytime": True,
                "temperature": 25,
                "temperatureUnit": "F",
                "windSpeed": "5 mph",
                "windDirection": "W",
                "shortForecast": "Sunny",
            }
        ]
    }
}

GRIDPOINT_RESPONSE = {
    "properties": {
        "snowfallAmount": {
            "uom": "wmoUnit:m",
            "values": [
                {"validTime": "2025-02-26T12:00:00Z/PT1H", "value": 0.01}
            ],
        },
        "snowLevel": {
            "uom": "wmoUnit:m",
            "values": [
                {"validTime": "2025-02-26T12:00:00Z/PT1H", "value": 3000}
            ],
        },
    }
}


def _make_mock_response(json_data):
    mock_resp = MagicMock()
    mock_resp.json.return_value = json_data
    return mock_resp


def _mock_get_side_effect(url):
    if "points/" in url:
        return _make_mock_response(POINTS_RESPONSE)
    if "gridpoint" in url:
        return _make_mock_response(GRIDPOINT_RESPONSE)
    return _make_mock_response(FORECAST_RESPONSE)


@patch("data_collector.main.httpx.Client")
def test_fetch_endpoint_with_mocked_api(mock_client_class, db_session):
    mock_client = MagicMock()
    mock_client.get.side_effect = _mock_get_side_effect
    mock_client_class.return_value.__enter__.return_value = mock_client
    mock_client_class.return_value.__exit__.return_value = None

    def override_get_db():
        try:
            yield db_session
        finally:
            pass

    app.dependency_overrides[get_db] = override_get_db
    try:
        client = TestClient(app)
        response = client.post("/fetch")
        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "success"
        assert "details" in data
        assert "summary" in data
        assert data["summary"]["weather_recs"] >= 0
        assert data["summary"]["snow_recs"] >= 0
    finally:
        app.dependency_overrides.pop(get_db, None)


@patch("data_collector.main.httpx.Client")
def test_sync_all_weather_writes_to_db(mock_client_class, db_session):
    mock_client = MagicMock()
    mock_client.get.side_effect = _mock_get_side_effect
    mock_client_class.return_value.__enter__.return_value = mock_client
    mock_client_class.return_value.__exit__.return_value = None

    result = sync_all_weather(db_session)

    assert len(result) > 0
    for resort_name, counts in result.items():
        assert "weather" in counts
        assert "snow" in counts
        assert counts["weather"] >= 0
        assert counts["snow"] >= 0

    loc = db_session.query(Location).first()
    assert loc is not None
    assert loc.forecast_url is not None
    assert loc.gridpoint_url is not None

    weather_count = db_session.query(WeatherRecord).filter_by(location_id=loc.id).count()
    snow_count = db_session.query(SnowRecord).filter_by(location_id=loc.id).count()
    assert weather_count == 1
    assert snow_count == 1


@patch("data_collector.main.httpx.Client")
def test_sync_all_weather_with_preexisting_location(mock_client_class, db_session):
    loc = Location(
        name="Aspen",
        latitude=39.1911,
        longitude=-106.8175,
        forecast_url="https://api.weather.gov/fake/forecast",
        gridpoint_url="https://api.weather.gov/fake/gridpoint",
    )
    db_session.add(loc)
    db_session.commit()

    mock_client = MagicMock()
    mock_client.get.side_effect = _mock_get_side_effect
    mock_client_class.return_value.__enter__.return_value = mock_client
    mock_client_class.return_value.__exit__.return_value = None

    result = sync_all_weather(db_session)

    assert "Aspen" in result
    assert result["Aspen"]["weather"] == 1
    assert result["Aspen"]["snow"] == 1


@patch("data_collector.main.httpx.Client")
def test_sync_all_weather_handles_forecast_error(mock_client_class, db_session):
    call_count = 0

    def failing_get(url):
        nonlocal call_count
        call_count += 1
        if call_count <= 3:  # Aspen: points, forecast, grid all succeed
            return _mock_get_side_effect(url)
        if call_count == 4:  # Vail: points succeeds
            return _make_mock_response(POINTS_RESPONSE)
        if call_count == 5:  # Vail: forecast fails
            raise Exception("Forecast API error")
        return _mock_get_side_effect(url)

    mock_client = MagicMock()
    mock_client.get.side_effect = failing_get
    mock_client_class.return_value.__enter__.return_value = mock_client
    mock_client_class.return_value.__exit__.return_value = None

    result = sync_all_weather(db_session)

    assert "Aspen" in result
    assert result["Aspen"]["weather"] == 1
    assert result["Aspen"]["snow"] == 1
    assert "Vail" in result
    assert result["Vail"]["weather"] == 0
    assert result["Vail"]["snow"] == 0
