# Cursor. (2026). Cursor Composer (Version 1.5) [Large language model]. https://cursor.com/
# Citation applies to: Lines 1-final. Generated by Cursor; revised and integrated by me.
#
# Observability must be set up before importing database (so SQLAlchemy engine is instrumented)
from data_collector.observability import setup_observability

setup_observability(service_name="weather-collector")

from contextlib import asynccontextmanager
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session

from data_collector.database import get_db, engine
from data_collector.models import Base, Location, WeatherRecord, SnowRecord

import logging
import httpx
from datetime import datetime

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("weather_collector")

@asynccontextmanager
async def lifespan(app: FastAPI):
    Base.metadata.create_all(bind=engine)
    yield

app = FastAPI(title="Colorado Snow Tracker", lifespan=lifespan)

# Instrument FastAPI for request tracing (after app is created)
from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor

FastAPIInstrumentor.instrument_app(app)


@app.get("/health")
def health():
    return {"status": "ok"}

UA_HEADERS = {"User-Agent": "WeatherApp/1.0 (contact@example.com)"}

TARGET_RESORTS = [
    {"name": "Aspen", "lat": 39.1911, "lon": -106.8175},
    {"name": "Vail", "lat": 39.6403, "lon": -106.3742},
    {"name": "Steamboat", "lat": 40.4850, "lon": -106.8317},
    {"name": "Eldora", "lat": 39.9375, "lon": -105.5836},
    {"name": "Copper", "lat": 39.5017, "lon": -106.1561},
    {"name": "Arapahoe Basin", "lat": 39.6425, "lon": -105.8722},
    {"name": "Winter Park", "lat": 39.8868, "lon": -105.7625},
    {"name": "Breckenridge", "lat": 39.4817, "lon": -106.0384},
    {"name": "Keystone", "lat": 39.6084, "lon": -105.9437},
    {"name": "Telluride", "lat": 37.9392, "lon": -107.8163},
]

@app.post("/fetch")
def run_sync_job(db: Session = Depends(get_db)):
    print("Starting sync")
    
    stats = sync_all_weather(db)
    
    w_total = sum(s["weather"] for s in stats.values())
    s_total = sum(s["snow"] for s in stats.values())
    
    return {
        "status": "success",
        "details": stats,
        "summary": {"weather_recs": w_total, "snow_recs": s_total}
    }

# helper function to sync the weather data for all resorts
# This function was initially written by hand and refined using Cursor (Composer 1.5) to fix functionality (isostrings being cleaned) 
def sync_all_weather(db: Session):
    final_counts = {}
    
    with httpx.Client(timeout=45.0, headers=UA_HEADERS) as client:
        for resort_spec in TARGET_RESORTS:
            resort = db.query(Location).filter_by(name=resort_spec["name"]).first()
            
            # if the resort is not in the database
            if not resort:
                resort = Location(name=resort_spec["name"], latitude=resort_spec["lat"], longitude=resort_spec["lon"])
                db.add(resort)
                db.flush()

            # if the resort is in the database, but the forecast_url is not set, set it
            if not resort.forecast_url:
                try:
                    response = client.get(f"https://api.weather.gov/points/{resort.latitude},{resort.longitude}")
                    props = response.json()["properties"]
                    resort.forecast_url = props["forecast"]
                    resort.gridpoint_url = props["forecastGridData"]
                except Exception as e:
                    logger.warning(f"metadata failed for {resort.name}: {e}")
                    continue

            try:
                # get the general forecast (temperature, etc,)
                forecast = client.get(resort.forecast_url).json()
                periods = forecast["properties"]["periods"]
                
                # delete old records
                db.query(WeatherRecord).filter_by(location_id=resort.id).delete()
                
                for period in periods:
                    # fixing the times
                    start_str = period["startTime"].replace("Z", "+00:00")
                    end_str = period["endTime"].replace("Z", "+00:00")

                    db.add(WeatherRecord(
                        location_id=resort.id,
                        period_number=period.get("number"),
                        period_name=period.get("name"),
                        start_time=datetime.fromisoformat(start_str),
                        end_time=datetime.fromisoformat(end_str),
                        is_daytime=period.get("isDaytime"),
                        temperature=period.get("temperature"),
                        temperature_unit=period.get("temperatureUnit"),
                        temperature_trend=period.get("temperatureTrend"),
                        wind_speed=period.get("windSpeed"),
                        wind_direction=period.get("windDirection"),
                        short_forecast=period.get("shortForecast"),
                        detailed_forecast=period.get("detailedForecast"),
                    ))
                # get the snow data (snowfall, etc.)
                snow = client.get(resort.gridpoint_url).json()
                snow_properties = snow["properties"]
                
                # snow and snowlevel are separate lists, group by timestamp
                snow_by_time = {}
                snowfall_unit = snow_properties.get("snowfallAmount", {}).get("uom", "wmoUnit:cm")
                for field in ["snowfallAmount", "snowLevel"]:
                    prop_data = snow_properties.get(field, {})
                    unit = prop_data.get("uom", "wmoUnit:m")
                    
                    for entry in prop_data.get("values", []):
                        valid_time = entry["validTime"]

                        if valid_time not in snow_by_time:
                            fixed_time = valid_time.split("/")[0].replace("Z", "+00:00")
                            snow_by_time[valid_time] = {
                                "ts": datetime.fromisoformat(fixed_time),
                                "unit": snowfall_unit if field == "snowfallAmount" else unit,
                            }

                        if field == "snowfallAmount":
                            snow_by_time[valid_time]["amt"] = entry["value"]
                        else:
                            snow_by_time[valid_time]["lvl"] = entry["value"]


                # delete old snow records from database and replace
                db.query(SnowRecord).filter_by(location_id=resort.id).delete()
                for snow_record in snow_by_time.values():
                    db.add(SnowRecord(
                        location_id=resort.id,
                        valid_time_start=snow_record["ts"],
                        snowfall_amount=snow_record.get("amt"),
                        snow_level=snow_record.get("lvl"),
                        snowfall_unit=snow_record["unit"]
                    ))

                db.commit()
                final_counts[resort.name] = {"weather": len(periods), "snow": len(snow_by_time)}

            # rollback
            except Exception as err:
                db.rollback()
                logger.error(f"Error updating {resort.name}: {err}")
                final_counts[resort.name] = {"weather": 0, "snow": 0}

    return final_counts

